{"version":3,"sources":["App.js","index.js"],"names":["TasksApp","useImmer","filterType","tasks","appState","updateState","Task","title","completed","toggleTask","className","style","textDecoration","onClick","createTaskServer","id","length","state","alert","PostTaksPromise","fetch","url","method","body","JSON","stringify","headers","then","response","json","console","log","map","task","reverse_status","togglePromise","fetchPromise","ok","Error","status","a","TaskForm","taskInput","taskAction","onSubmit","event","preventDefault","value","ref","r","type","TodoFilter","setFilterType","i","window","confirm","list","index","push","toLowerCase","forEach","item","includes","fetchAsyncWait","filter","App","rootElement","document","getElementById","ReactDOM","render"],"mappings":"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","file":"static/js/main.b1ff5754.chunk.js","sourcesContent":["import \"./styles.css\";\nimport { useImmer } from \"use-immer\";\nimport { render } from \"react-dom\";\n\n// // ID generator\n// function* idMaker() {\n//   var index = 0;\n//   while (true) yield index++;\n// }\n// var gen = idMaker();\n\nconst TasksApp = () => {\n  const [appState, updateState] = useImmer({\n    filterType: \"all\",\n    tasks: []\n  });\n\n  const Task = ({ title, completed, toggleTask }) => {\n    return (\n      <li\n        className=\"task-row\"\n        style={{\n          textDecoration: completed ? \"line-through\" : \"none\"\n        }}\n        onClick={toggleTask}\n      >\n        {title}\n      </li>\n    );\n  };\n\n  // this create tasks from the server\n  const createTaskServer = (title, id, completed) => {\n    // only update if the input is not blank\n    title.length > 0\n      ? updateState((state) => ({\n          ...state,\n          tasks: [\n            ...state.tasks,\n            { id: id, title: title, completed: completed }\n          ]\n        }))\n      : alert(\"Please Input a Task\");\n  };\n\n  // this creates a task locally by manually inputing\n  const createTask = (title) => {\n    // only update if the input is not blank\n    title.length > 0\n      ? updateState((state) => ({\n          ...state,\n          tasks: [\n            ...state.tasks,\n            { id: appState.tasks.length + 1, title: title, completed: false }\n          ]\n        }))\n      : alert(\"Please Input a Task\");\n    // only save to the server if confirmed, else create it locally\n    if (\n      window.confirm(\n        \"Are you sure you want to save this new task into the database?\"\n      )\n    ) {\n      // save it to the server\n      PostTaksPromise(title, appState.tasks.length + 1);\n      console.log(\"This is saved to database\");\n    } else {\n      console.log(\"This is not saved to database but created locally\");\n    }\n  };\n\n  // when you create a new tasks, pass the new task to the server\n  const PostTaksPromise = (title, id) => {\n    // id on server is the next list item id + 1\n    fetch(url, {\n      method: \"POST\",\n      body: JSON.stringify({\n        id: `${id}`,\n        title: `${title}`,\n        completed: false\n      }),\n      headers: {\n        \"Content-type\": \"application/json; charset=UTF-8\"\n      }\n    })\n      .then((response) => response.json())\n      .then((json) => console.log(json));\n  };\n\n  // when you toggle the tasks, reflect the change to the server by patching\n  // fetch for the current state of the id\n  // if for that id, if it's complete, change to incomplete, vice versa\n  const togglePromise = (id) => {\n    // reverse the current state if toggle\n    let reverse_status = appState.tasks[id - 1].completed ? false : true;\n    fetch(url + `/${id}`, {\n      method: \"PATCH\",\n      body: JSON.stringify({\n        completed: reverse_status\n      }),\n      headers: {\n        \"Content-type\": \"application/json; charset=UTF-8\"\n      }\n    })\n      .then((response) => {\n        return response.json();\n      })\n      .then((json) => console.log(json));\n  };\n\n  const toggleTask = (id) => {\n    updateState((state) => ({\n      ...state,\n      tasks: state.tasks.map((task) =>\n        task.id === id ? { ...task, completed: !task.completed } : task\n      )\n    }));\n    // console.log(id);\n    // console.log(appState.tasks);\n    // console.log(appState.tasks[id - 1]);\n    togglePromise(id);\n  };\n\n  // onClick of the button, then fetch and create tasks\n  const url = \"https://zhiying-to-do-list.herokuapp.com/tasks\";\n\n  // promise has no wait time, it throws error right away if something is wrong\n  const fetchPromise = fetch(url).then((response) => {\n    if (!response.ok) {\n      throw new Error(`Promise Alert: HTTP error! status: ${response.status}`);\n    }\n    return response.json();\n  });\n\n  const updateFromPromise = () => {\n    // Get the current list of title\n    var list = [];\n    appState.tasks.map((value, index) => list.push(value.title.toLowerCase()));\n\n    //Only create tasks if task does not exist,else alert\n    fetchPromise.then((response) => {\n      response.tasks.forEach((item) => {\n        list.includes(item.title.toLowerCase())\n          ? alert(`Task ${item.title} already exist`)\n          : createTaskServer(item.title, item.id, item.completed);\n      });\n      console.log(response.tasks);\n    });\n  };\n\n  //using async and wait\n  async function fetchAsyncWait() {\n    const response = await fetch(url);\n    if (!response.ok) {\n      throw new Error(\n        `AsyncWait Alert: HTTP error! status: ${response.status}`\n      );\n    }\n    const tasks = await response.json();\n    return tasks;\n  }\n\n  const updateFromAsync = () => {\n    // Get the current list of title\n    var list = [];\n    appState.tasks.map((value, index) => list.push(value.title.toLowerCase()));\n\n    fetchAsyncWait().then((response) => {\n      response.tasks.forEach((item) => {\n        list.includes(item.title.toLowerCase())\n          ? alert(`Task ${item.title} already exist`)\n          : createTaskServer(item.title, item.id, item.completed);\n      });\n    });\n  };\n\n  const TaskForm = ({ taskAction }) => {\n    // variable to hold a reference to the input\n    let taskInput;\n\n    const handleSubmit = (event) => {\n      if (appState.tasks.length === 0) {\n        alert(\"Please Synchronize with Server Before Creating Task Manually\");\n        event.preventDefault();\n      } else {\n        event.preventDefault();\n        taskAction(taskInput.value);\n        taskInput.value = \"\";\n      }\n    };\n    return (\n      <form onSubmit={handleSubmit}>\n        <label>\n          <input\n            className=\"task-input\"\n            ref={(r) => (taskInput = r)}\n            type=\"text\"\n          />\n        </label>\n        <input\n          className=\"task-button\"\n          type=\"submit\"\n          value=\"Create Task Manually\"\n        />\n      </form>\n    );\n  };\n\n  const TodoFilter = ({ filterType, setFilterType }) => (\n    <span>\n      <b className=\"filter-text\">Filter Tasks: </b>\n      {[\"all\", \"completed\", \"active\"].map((status, i) => (\n        <button\n          className=\"filter-buttons\"\n          key={i}\n          onClick={() => setFilterType(status)}\n        >\n          {status}\n        </button>\n      ))}\n    </span>\n  );\n\n  const filteredTasks = () => {\n    return appState.filterType === \"all\"\n      ? appState.tasks\n      : appState.tasks.filter(\n          (task) => task.completed === (appState.filterType === \"completed\")\n        );\n  };\n\n  const setFilterType = (filterType) => {\n    updateState((state) => ({ ...state, filterType }));\n  };\n\n  // when you enter, the value from taskForm is being passed to createTask\n\n  return (\n    <div>\n      <h1> Zhiying's To-Do List</h1>\n      <TaskForm taskAction={createTask} />\n      <button className=\"fetch-buttons\" onClick={updateFromPromise}>\n        Synchronize with Server (Promise)\n      </button>\n      <button className=\"fetch-buttons\" onClick={updateFromAsync}>\n        Synchronize with Server (Async/Wait)\n      </button>\n      <h3> </h3>\n\n      <TodoFilter\n        filterType={appState.filterType}\n        setFilterType={setFilterType}\n      />\n      <ul>\n        {filteredTasks().map((task) => (\n          <Task\n            key={task.id}\n            title={task.title}\n            completed={task.completed}\n            toggleTask={() => toggleTask(task.id)}\n          />\n        ))}\n      </ul>\n    </div>\n  );\n};\n\nexport default function App() {\n  return (\n    <div className=\"App\">\n      <TasksApp />\n    </div>\n  );\n}\n","import { StrictMode } from \"react\";\nimport ReactDOM from \"react-dom\";\n\nimport App from \"./App\";\n\nconst rootElement = document.getElementById(\"root\");\nReactDOM.render(\n  <StrictMode>\n    <App />\n  </StrictMode>,\n  rootElement\n);\n"],"sourceRoot":""}